################################################################
# IBM for evolution of cells producing toxins as a public good #
#               Author: Elias Ehrlich                          #
#                 Date: 26/05/2019                             #
################################################################
## Packages
using Plots
using Colors
using Distributions
using Random

#Random.seed!(1234)

## Parameters
L=10^4      # Number of discrete 'positions' per dimension (resolution 0.0001)
tmax=100    # simulation steps
N0=4000     # initial number of cells
c0=0.1       # initial frequency of toxic cells
Δ=0.001      # root mean square (standard dev.) of Gaussian distributed random variable for diffusion
U=0.1        # amplitude of turbulence movement wave
pC=0.26       # birth probability of toxic cells
qC=0.25       # death probability of toxic cells
pD=0.28       # birth probability of non-toxic cells
qD=0.25       # death probability of non-toxic cells
gC_max=0.1    # maximum grazing loss probability
gD_max=0.1    # maximum grazing loss probability
H=2           # toxicity at which grazing loss probability is halfed

## Predefine local toxicity environment around one cell
xTox=range(-4*Δ,4*Δ,step=1/L)   # local x-range
yTox=range(-4*Δ,4*Δ,step=1/L)   # local y-range
n=length(xTox)                  # number of patches along range
nC=floor(Int,(n-1)/2)           # number of patches from outer margin of local env. to central toxic cell
LocalTox=zeros(n,n)         # local toxicity environment around one toxic cell
for i in 1:n, j in 1:n
    LocalTox[i,j] = pdf(MvNormal([0.0; 0.0], [Δ^2 0.0; 0.0 Δ^2]),[xTox[i];yTox[j]]) # pdf of multivariate normal distribution
end
MaxP=pdf(MvNormal([0.0; 0.0], [Δ^2 0.0; 0.0 Δ^2]),[0;0]) # probability density at mean x and mean y
LocalTox=LocalTox./MaxP         # rescale the values --> between 0 and 1
surface(xTox,yTox,LocalTox, size=[800,480],camera=(50,50),xlabel="x",ylabel="y")

## Initialization
global AC = rand(0:L,(floor(Int,c0*N0),2))  # Toxic cells --> random x- and y-positions between 0 and L
global AD = rand(0:L,(floor(Int,(1-c0)*N0),2))  # Non-toxic cells --> random x- and y-positions between 0 and L

global AC1=copy(AC)
global AD1=copy(AD)

scatter(AD[:,1].*1/L,AD[:,2].*1/L,xlabel="x",ylabel="y",
    mc=:steelblue,msc=:black,ms=2,msw=0.0,
    legend=false,dpi=600,reuse=false)
scatter!(AC[:,1].*1/L,AC[:,2].*1/L,mc=:red,msc=:black,ms=2,msw=0.0)
xlims!((0.0,1.0))
ylims!((0.0,1.0))

#savefig("D:\\Forschung\\Denmark Ocean Life\\Toxicity Project\\Figures\\AdvDiff\\Tox_AdvDiff_t0")

### Simulation
for t in 1:tmax
    ## demography
    # toxic cells
    rv=rand(size(AC,1))                              # random variable for demography
    CellsSurv=findall(x->x>qC,rv)                    # row numbers of surviving cells
    global AC1=AC[CellsSurv,:]                       # remove dead cells
    CellsReprod=findall(x->x>(1-pC),rv[CellsSurv])   # row number of reproducing cells
    global AC1=vcat(AC1,AC1[CellsReprod,:])
    # non-toxic cells                      # add offsprings --> same position as parents
    rv=rand(size(AD,1))                              # random variable for demography
    CellsSurv=findall(x->x>qD,rv)                    # row numbers of surviving cells
    global AD1=AD[CellsSurv,:]                       # remove dead cells
    CellsReprod=findall(x->x>(1-pD),rv[CellsSurv])   # row number of reproducing cells
    global AD1=vcat(AD1,AD1[CellsReprod,:])

    global AC = copy(AC1)   # update matrices
    global AD = copy(AD1)   # update matrices

    ## diffusion
    # toxic cells
    dxC=rand(Normal(0,Δ),size(AC,1))     # gaussian distributed random variable (mean=0, sd=rms=Δ)
    dyC=rand(Normal(0,Δ),size(AC,1))     # gaussian distributed random variable (mean=0, sd=rms=Δ)
    dxC=floor.(Int,dxC.*L)                # discretizing
    dyC=floor.(Int,dyC.*L)                # discretizing
    AC[:,1]=mod.(AC[:,1].+dxC,L)          # modulo for torus
    AC[:,2]=mod.(AC[:,2].+dyC,L)          # modulo for torus
    # non-toxic cells
    dxD=rand(Normal(0,Δ),size(AD,1))     # gaussian distributed random variable (mean=0, sd=rms=Δ)
    dyD=rand(Normal(0,Δ),size(AD,1))     # gaussian distributed random variable (mean=0, sd=rms=Δ)
    dxD=floor.(Int,dxD.*L)                # discretizing
    dyD=floor.(Int,dyD.*L)                # discretizing
    AD[:,1]=mod.(AD[:,1].+dxD,L)         # modulo for torus
    AD[:,2]=mod.(AD[:,2].+dyD,L)         # modulo for torus

    # ## turbulence
    # phi=rand()*2*pi     # for turbulence in x-direction
    # theta=rand()*2*pi   # for turbulence in y-direction
    # # toxic cells
    # ddxC=U.*cos.(2*pi*AC[:,2].+phi) # movement in x-direction
    # ddxC=floor.(Int,ddxC.*L)                # discretizing
    # AC[:,1]=mod.(AC[:,1].+ddxC,L)
    # ddyC=U.*cos.(2*pi*AC[:,1].+theta)
    # ddyC=floor.(Int,ddyC.*L)                # discretizing
    # AC[:,2]=mod.(AC[:,2].+ddyC,L)
    # # non-toxic cells
    # ddxD=U.*cos.(2*pi*AD[:,2].+phi) # movement in x-direction
    # ddxD=floor.(Int,ddxD.*L)                # discretizing
    # AD[:,1]=mod.(AD[:,1].+ddxD,L)
    # ddyD=U.*cos.(2*pi*AD[:,1].+theta)
    # ddyD=floor.(Int,ddyD.*L)                # discretizing
    # AD[:,2]=mod.(AD[:,2].+ddyD,L)
end

scatter(AD[:,1].*1/L,AD[:,2].*1/L,xlabel="x",ylabel="y",
    mc=:steelblue,msc=:black,ms=1.8,msw=0.0,
    legend=false,dpi=600,reuse=false)
scatter!(AC[:,1].*1/L,AC[:,2].*1/L,mc=:red,msc=:black,ms=1.8,msw=0.0)
xlims!((0.0,1.0))
ylims!((0.0,1.0))

#savefig("D:\\Forschung\\Denmark Ocean Life\\Toxicity Project\\Figures\\AdvDiff\\Tox_AdvDiff_t0")
#savefig("D:\\Forschung\\Denmark Ocean Life\\Toxicity Project\\Figures\\AdvDiff\\Tox_AdvDiff_t$tmax")

## Calculate toxicity environment
GlobalTox=zeros(L+1,L+1)                  # global toxicity environment (whole space)
for i in 1:size(AC,1)   # loop through all toxic cells
    xrange=AC[i,1]+1-nC:AC[i,1]+1+nC    # +1 as AC has values from 0 to 10000 --> corresponding to an index from 1 to 10001
    xrange=mod.(xrange.-1,L+1).+1       # for torus
    yrange=AC[i,2]+1-nC:AC[i,2]+1+nC
    yrange=mod.(yrange.-1,L+1).+1
    GlobalTox[xrange,yrange]=GlobalTox[xrange,yrange].+LocalTox # add toxicity effect of the considered cell
end

## Grazing event
rv_gC=rand(size(AC,1))
IndexC=(AC[:,2].-1 .+1).*(L+1).+AC[:,1]     # one dimensional index
gC=gC_max.*(1.0.-GlobalTox[IndexC]./(H.+GlobalTox[IndexC]))
SurvGrazC=rv_gC.>gC        # row numbers of surviving cells
AC=AC[SurvGrazC,:]

rv_gD=rand(size(AD,1))
IndexD=(AD[:,2].-1 .+1).*(L+1).+AD[:,1]     # one dimensional index
gD=gD_max.*(1.0.-GlobalTox[IndexD]./(H.+GlobalTox[IndexD]))
SurvGrazD=rv_gD.>gD        # row numbers of surviving cells
AD=AD[SurvGrazD,:]

scatter(AD[:,1].*1/L,AD[:,2].*1/L,xlabel="x",ylabel="y",
    mc=:steelblue,msc=:black,ms=1.8,msw=0.0,
    legend=false,dpi=600,reuse=false)
scatter!(AC[:,1].*1/L,AC[:,2].*1/L,mc=:red,msc=:black,ms=1.8,msw=0.0)
xlims!((0.0,1.0))
ylims!((0.0,1.0))

# xTotal=range(0,1,length=L+1)
# yTotal=range(0,1,length=L+1)
# surface(xTotal[4000:6000],yTotal[4000:6000],GlobalTox[4000:6000,4000:6000], xlabel="x",ylabel="y")
