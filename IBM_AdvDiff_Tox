################################################################
# IBM for evolution of cells producing toxins as a public good #
#               Author: Elias Ehrlich                          #
#                 Date: 26/05/2019                             #
################################################################
## Packages
using Plots
using Colors
using Distributions
using Random

#Random.seed!(1234)

## Parameters
L=10^4        # Number of discrete 'positions' per dimension (resolution 0.0001)
tmax=30       # simulation steps
N0=20000       # initial number of cells
c0=0.1        # initial frequency of toxic cells
Δ=0.001       # root mean square (standard dev.) of Gaussian distributed random variable for diffusion
U=0.1         # amplitude of turbulence movement wave
pC_max=0.35   # max. birth probability of toxic cells
qC=0.25       # death probability of toxic cells
pD_max=0.35   # max. birth probability of non-toxic cells
qD=0.25       # death probability of non-toxic cells
gC_max=0.1    # maximum grazing loss probability of toxic cells
gD_max=0.1    # maximum grazing loss probability of non-toxic cells
H=2           # toxicity at which grazing loss probability is halfed
Nmax=10^6     # total resources in units of cells (maximum number of cells)
αC=2*10^-5    # resource affinity of toxic cells (d^-1 cells^-1)
αD=3*10^-5    # resource affinity of toxic cells (d^-1 cells^-1)

## Predefine local toxicity environment around one cell
xTox=range(-3*Δ,3*Δ,step=1/L)   # local x-range
yTox=range(-3*Δ,3*Δ,step=1/L)   # local y-range
n=length(xTox)                  # number of patches along range
nC=floor(Int,(n-1)/2)           # number of patches from outer margin of local env. to central toxic cell
LocalTox=zeros(n,n)             # local toxicity environment around one toxic cell
for i in 1:n, j in 1:n
    LocalTox[i,j] = pdf(MvNormal([0.0; 0.0], [Δ^2 0.0; 0.0 Δ^2]),[xTox[i];yTox[j]]) # pdf of multivariate normal distribution
end
MaxP=pdf(MvNormal([0.0; 0.0], [Δ^2 0.0; 0.0 Δ^2]),[0;0]) # probability density at mean x and mean y
LocalTox=LocalTox./MaxP         # rescale the values --> between 0 and 1
surface(xTox,yTox,LocalTox, size=[800,480],camera=(50,50),xlabel="x",ylabel="y",zlabel="toxin conc.",dpi=600)

#savefig("D:\\Forschung\\Denmark Ocean Life\\Toxicity Project\\Figures\\AdvDiff\\LocalToxEnv")

## Initialization
global AC = rand(0:L,(floor(Int,c0*N0),2))  # Toxic cells --> random x- and y-positions between 0 and L
global AD = rand(0:L,(floor(Int,(1-c0)*N0),2))  # Non-toxic cells --> random x- and y-positions between 0 and L

global AC1=copy(AC)
global AD1=copy(AD)

scatter(AD[:,1].*1/L,AD[:,2].*1/L,xlabel="x",ylabel="y",
    mc=:steelblue,msc=:black,ms=2,msw=0.0,
    legend=false,dpi=600,reuse=false)
scatter!(AC[:,1].*1/L,AC[:,2].*1/L,mc=:red,msc=:black,ms=2,msw=0.0)
xlims!((0.0,1.0))
ylims!((0.0,1.0))

#savefig("D:\\Forschung\\Denmark Ocean Life\\Toxicity Project\\Figures\\AdvDiff\\Tox_AdvDiff_t0")

FreqC_timeser=zeros(tmax+1)                             # frequency of toxic cells
FreqC_timeser[1]=size(AC,1)/(size(AC,1)+size(AD,1))     # initial frequency of toxic cells

### Simulation
@time for t in 1:tmax
    ## birth, death and grazing loss
    # Calculate competition environment
    R=Nmax-size(AC,1)-size(AD,1)   # resources
    pC=pC_max*R/(pC_max/αC+R)      # resource-dependent birth probability of toxic cells
    pD=pD_max*R/(pD_max/αD+R)      # resource-dependent birth probability of non-toxic cells

    # Calculate toxicity environment
    GlobalTox=zeros(L+1,L+1)                # global toxicity environment (whole space)
    for i in 1:size(AC,1)                   # loop through all toxic cells
        xrange=AC[i,1]+1-nC:AC[i,1]+1+nC    # +1 as AC has values from 0 to 10000 --> corresponding to an index from 1 to 10001
        xrange=mod.(xrange.-1,L+1).+1       # for torus
        yrange=AC[i,2]+1-nC:AC[i,2]+1+nC
        yrange=mod.(yrange.-1,L+1).+1
        GlobalTox[xrange,yrange]=GlobalTox[xrange,yrange].+LocalTox # add toxicity effect of the considered cell
    end
    IndexC=AC[:,2].*(L+1).+AC[:,1]     # one dimensional index - position of toxic cells
    IndexD=AD[:,2].*(L+1).+AD[:,1]     # one dimensional index - position of non-toxic cells
    gC=gC_max.*(1.0.-GlobalTox[IndexC]./(H.+GlobalTox[IndexC]))     # ingestion probability of toxic cell
    gD=gD_max.*(1.0.-GlobalTox[IndexD]./(H.+GlobalTox[IndexD]))     # ingestion probability of non-toxic cell

    # toxic cells
    rv=rand(size(AC,1))
    CellsSurv=rv.>(qC.+gC)                            # rows of surviving cells (marked with 'true')
    global AC1=AC[CellsSurv,:]                       # remove dead cells
    CellsReprod=findall(x->x>(1-pC),rv[CellsSurv])   # row number of reproducing cells
    global AC1=vcat(AC1,AC1[CellsReprod,:])          # add offsprings --> same position as parents
    # non-toxic cells
    rv=rand(size(AD,1))
    CellsSurv=rv.>(qD.+gD)                            # rows of surviving cells (marked with 'true')
    global AD1=AD[CellsSurv,:]                       # remove dead cells
    CellsReprod=findall(x->x>(1-pD),rv[CellsSurv])   # row number of reproducing cells
    global AD1=vcat(AD1,AD1[CellsReprod,:])          # add offsprings --> same position as parents

    global AC = copy(AC1)   # update matrices
    global AD = copy(AD1)   # update matrices

    ## diffusion
    # toxic cells
    dxC=rand(Normal(0,Δ),size(AC,1))     # gaussian distributed random variable (mean=0, sd=rms=Δ)
    dyC=rand(Normal(0,Δ),size(AC,1))     # gaussian distributed random variable (mean=0, sd=rms=Δ)
    dxC=floor.(Int,dxC.*L)                # discretizing
    dyC=floor.(Int,dyC.*L)                # discretizing
    AC[:,1]=mod.(AC[:,1].+dxC,L)          # modulo for torus
    AC[:,2]=mod.(AC[:,2].+dyC,L)          # modulo for torus
    # non-toxic cells
    dxD=rand(Normal(0,Δ),size(AD,1))     # gaussian distributed random variable (mean=0, sd=rms=Δ)
    dyD=rand(Normal(0,Δ),size(AD,1))     # gaussian distributed random variable (mean=0, sd=rms=Δ)
    dxD=floor.(Int,dxD.*L)                # discretizing
    dyD=floor.(Int,dyD.*L)                # discretizing
    AD[:,1]=mod.(AD[:,1].+dxD,L)         # modulo for torus
    AD[:,2]=mod.(AD[:,2].+dyD,L)         # modulo for torus

    # ## turbulence
    # phi=rand()*2*pi     # for turbulence in x-direction
    # theta=rand()*2*pi   # for turbulence in y-direction
    # # toxic cells
    # ddxC=U.*cos.(2*pi*AC[:,2].+phi) # movement in x-direction
    # ddxC=floor.(Int,ddxC.*L)                # discretizing
    # AC[:,1]=mod.(AC[:,1].+ddxC,L)
    # ddyC=U.*cos.(2*pi*AC[:,1].+theta)
    # ddyC=floor.(Int,ddyC.*L)                # discretizing
    # AC[:,2]=mod.(AC[:,2].+ddyC,L)
    # # non-toxic cells
    # ddxD=U.*cos.(2*pi*AD[:,2].+phi) # movement in x-direction
    # ddxD=floor.(Int,ddxD.*L)                # discretizing
    # AD[:,1]=mod.(AD[:,1].+ddxD,L)
    # ddyD=U.*cos.(2*pi*AD[:,1].+theta)
    # ddyD=floor.(Int,ddyD.*L)                # discretizing
    # AD[:,2]=mod.(AD[:,2].+ddyD,L)

    FreqC_timeser[t+1]=size(AC,1)/(size(AC,1)+size(AD,1))     # frequency of toxic cells
end

@time scatter(AD[:,1].*1/L,AD[:,2].*1/L,xlabel="x",ylabel="y",
    mc=:steelblue,msc=:black,ms=1.8,msw=0.0,
    legend=false,dpi=600,reuse=false)
scatter!(AC[:,1].*1/L,AC[:,2].*1/L,mc=:red,msc=:black,ms=1.8,msw=0.0)
xlims!((0.0,1.0))
ylims!((0.0,1.0))

#savefig("D:\\Forschung\\Denmark Ocean Life\\Toxicity Project\\Figures\\AdvDiff\\Tox_AdvDiff_t0")
#savefig("D:\\Forschung\\Denmark Ocean Life\\Toxicity Project\\Figures\\AdvDiff\\Tox_AdvDiff_t$tmax")

tt=0:tmax
plot(tt,FreqC_timeser,reuse=false,legend=false,xlabel="t",ylabel="Frequency of toxic cells",ylim=(0.0,1.0)) # --> a line
scatter!(tt,FreqC_timeser) # --> dots --> "!" = mutate plot --> add dots to previous plot

# xTotal=range(0,1,length=L+1)
# yTotal=range(0,1,length=L+1)
# surface(xTotal[4000:6000],yTotal[4000:6000],GlobalTox[4000:6000,4000:6000], xlabel="x",ylabel="y")
