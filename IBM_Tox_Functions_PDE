module IBM_Tox_Functions_PDE

    export Sim_Tox_Graz_PDE

    using FastConv
    using StatsBase
    # using Plots

    function findall3(f, a::Array{Int64,1})
        j = 1
        b = Vector{Int}(undef, length(a))
        @inbounds for i in eachindex(a)
            @inbounds if f(a[i])
                b[j] = i
                j += 1
            end
        end
        resize!(b, j-1)
        sizehint!(b, length(b))
        return b
    end

    function Diffusion(X::Array{Float64,2},kernel_2D::Array{Float64,2})
        Xnew=convn(X,kernel_2D)
        Xnew[:,2] = Xnew[:,2] .+ Xnew[:,end]
        Xnew[:,end-1] = Xnew[:,end-1] .+ Xnew[:,1]
        Xnew[2,:] = Xnew[2,:] .+ Xnew[end,:]
        Xnew[end-1,:] = Xnew[end-1,:] .+ Xnew[1,:]
        X=Xnew[2:end-1,2:end-1]
        return X
    end

    # function Move(xy::Array{Int64,1},Ngrid::Int64,Δ::Float64)
    #     mod.(round.(Int, xy.-1 .+ randn(length(xy)) .* Δ),Ngrid) .+ 1
    # end

    function RealReprod(PotBirth::BitArray{1},MaxNBirth::Int64)
        NPotBirth=length(PotBirth)
        NoBirth=maximum([0,NPotBirth-MaxNBirth]) # Number of potential births not realized
        IndexNoBirth=sample(1:NPotBirth,NoBirth,replace=false)
        PotBirth[IndexNoBirth].=false   # Realized birth

        return PotBirth
    end

    function Sim_Tox_Graz_PDE(C::Array{Float64,2},T::Array{Float64,2},xnon::Array{Int64,1},ynon::Array{Int64,1},
                        xtox::Array{Int64,1},ytox::Array{Int64,1},FreqTox::Array{Float64,1},PopDens ::Array{Float64,2},
                        Ngrid::Int64,Nt::Int64,λ::Float64,Q::Float64,Ptox::Float64,Pnon::Float64,mtox::Float64,
                        mnon::Float64,Gtox::Float64,Gnon::Float64,HC::Float64,HT::Float64,
                        qN::Float64,dt::Float64,kernel_2D::Array{Float64,2},Δ::Float64)
        @inbounds for t in 1:Nt
            ## 1. Birth and death of cells
            PosTox=@. (ytox-1)*Ngrid+xtox         # Linear index - position of toxic cells
            PosNon=@. (ynon-1)*Ngrid+xnon         # Linear index - position of non-toxic cells
            Pos=vcat(PosTox,PosNon)
            ptox=@. Ptox*C[PosTox]/(HC+C[PosTox])
            pnon=@. Pnon*C[PosNon]/(HC+C[PosNon])
            p=vcat(ptox,pnon)
            gtox=@. Gtox*(1.0-T[PosTox]/(HT+T[PosTox]))
            gnon=@. Gnon*(1.0-T[PosNon]/(HT+T[PosNon]))

            ### Birth
            rv=rand(length(Pos))
            CellsReprod=rv.<=p
            IndexReprodTrue=(1:length(CellsReprod))[CellsReprod]
            # IndexReprodTrue=findall(CellsReprod) # Indices of array CellsReprod at which =true
            AllPos=unique(Pos[IndexReprodTrue]) # All positions at which potential birth
            Threads.@threads for i in AllPos
                MaxNBirth=floor(Int,C[i]/qN)
                Ind_i=findall3(x -> (x == i), Pos[IndexReprodTrue])
                IndexReprodTrue_i=IndexReprodTrue[Ind_i]
                CellsReprod[IndexReprodTrue_i]=RealReprod(CellsReprod[IndexReprodTrue_i],MaxNBirth) # Correcting number of birth depending on nutrient concentration
            end
            CellsReprodTox=CellsReprod[1:length(PosTox)]
            CellsReprodNon=CellsReprod[length(PosTox)+1:end]
            xtox_birth=xtox[CellsReprodTox]
            ytox_birth=ytox[CellsReprodTox]
            xnon_birth=xnon[CellsReprodNon]
            ynon_birth=ynon[CellsReprodNon]

            ### Death
            rvtox=rand(length(xtox))
            rvnon=rand(length(xnon))
            CellsDeadTox=rvtox.<=(mtox.+gtox)                # Indices of dying cells (marked with 'true')
            CellsDeadNon=rvnon.<=(mnon.+gnon)
            CellsSurvTox=rvtox.>(mtox.+gtox)                # Indices of dying cells (marked with 'true')
            CellsSurvNon=rvnon.>(mnon.+gnon)
            xtox_dead=xtox[CellsDeadTox]
            ytox_dead=ytox[CellsDeadTox]
            xnon_dead=xnon[CellsDeadNon]
            ynon_dead=ynon[CellsDeadNon]

            ### Update population
            xtox=vcat(xtox[CellsSurvTox],xtox_birth)
            ytox=vcat(ytox[CellsSurvTox],ytox_birth)
            xnon=vcat(xnon[CellsSurvNon],xnon_birth)
            ynon=vcat(ynon[CellsSurvNon],ynon_birth)

            FreqTox[t+1]=length(xtox)/(length(xtox)+length(xnon))
            PopDens[t+1,:]=[length(xnon),length(xtox)]

            ## 2. Consumption and recycling of Nutrients
            ### Consume Nutrients
            PosBirth=(vcat(ytox_birth,ynon_birth).-1).*Ngrid.+vcat(xtox_birth,xnon_birth)   # Linear index - position of new born cells
            @inbounds for i in PosBirth
                C[i]=C[i]-qN
            end

            ### Recycle Nutrients
            PosDeath=(vcat(ytox_dead,ynon_dead).-1).*Ngrid.+vcat(xtox_dead,xnon_dead)   # Linear index - position of dead cells
            @inbounds for i in PosDeath
                C[i]=C[i]+qN
            end

            ## 3. Toxin leakage and decay
            PosTox=@. (ytox-1)*Ngrid+xtox
            T_decay=λ.*dt.*T
            ### Leak toxins
            @inbounds for i in PosTox
                T[i]=T[i]+Q*dt
            end
            ### Decay toxins
            T.=T.-T_decay

            ## 4. Movement/Diffusion of cells, nutrients and toxins
            ### Move cells
            # xtox = Move(xtox,Ngrid,Δ)
            # ytox = Move(ytox,Ngrid,Δ)
            # xnon = Move(xnon,Ngrid,Δ)
            # ynon = Move(ynon,Ngrid,Δ)

            xtox = mod.(round.(Int, xtox.-1 .+ randn(length(xtox)) .* Δ),Ngrid) .+ 1
            ytox = mod.(round.(Int, ytox.-1 .+ randn(length(xtox)) .* Δ),Ngrid) .+ 1
            xnon = mod.(round.(Int, xnon.-1 .+ randn(length(xnon)) .* Δ),Ngrid) .+ 1
            ynon = mod.(round.(Int, ynon.-1 .+ randn(length(xnon)) .* Δ),Ngrid) .+ 1


            ### Diffuse nutrients
            C=Diffusion(C,kernel_2D)

            ### Diffuse toxins
            T=Diffusion(T,kernel_2D)

            # ## Plot
            # p1=scatter(xnon,ynon,xlabel="x [cm]",ylabel="y [cm]",
            #     mc=:steelblue,msc=:black,ms=1.8,msw=0.0,
            #     legend=false,reuse=false, #dpi=600)
            #     xlims=(0,Ngrid),ylims=(0,Ngrid),title="t = $t",
            #     guidefontsize=8,titlefontsize=10)
            # scatter!(xtox,ytox,mc=:red,msc=:black,ms=1.8,msw=0.0)
            # p2=heatmap(transpose(C),clims=(0,K),title="Nutrient conc.",titlefontsize=10)
            # p3=heatmap(transpose(T),clims=(0,100),title="Toxin conc.",titlefontsize=10)
            # p4=plot(0:dt:t*dt,PopDens[1:(t+1),:],reuse=false,legend=false,xlabel="t [days]",ylabel="Abundance",
            #     xlims=(0,Nt*dt),ylim=(10^1,10^6),yaxis=:log,
            #     linecolor=[:steelblue :red],linewidth=2,guidefontsize=8)
            # pall=plot(p1,p2,p3,p4)
            # display(pall)

        end

        return C, T, xnon, ynon, xtox, ytox, FreqTox, PopDens
    end
end #module




# ### Diffuse columns
# for i in 1:Ngrid
#     # C[:,i] = imfilter(C[:,i],kernel, "circular") # Convolution for diffusion with imfilter function, mode "circular" for torus
#     Cnew = convn(C[:,i],kernel) # convn is from Package FastConv
#     Cnew[2] = Cnew[2] + Cnew[end]
#     Cnew[end-1] = Cnew[end-1] + Cnew[1]
#     C[:,i]=Cnew[2:end-1]
# end
#
# ### Diffuse rows
# for i in 1:Ngrid
#     # C[i,:] = imfilter(C[i,:],kernel, "circular") # Convolution for diffusion with imfilter function, mode "circular" for torus
#     Cnew = convn(C[i,:],kernel)
#     Cnew[2] = Cnew[2] + Cnew[end]
#     Cnew[end-1] = Cnew[end-1] + Cnew[1]
#     C[i,:]=Cnew[2:end-1]
# end
